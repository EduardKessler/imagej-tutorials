{
    "beaker": "2",
    "evaluators": [
        {
            "name": "HTML",
            "plugin": "HTML",
            "view": {
                "cm": {
                    "mode": "htmlmixed"
                }
            }
        },
        {
            "name": "JavaScript",
            "plugin": "JavaScript",
            "view": {
                "cm": {
                    "mode": "javascript",
                    "background": "#FFE0F0"
                }
            },
            "languageVersion": "ES2015"
        },
        {
            "name": "Groovy",
            "plugin": "Groovy",
            "imports": "graxxia.*\ncom.twosigma.beaker.NamespaceClient\ncom.twosigma.beaker.BeakerProgressUpdate\ncom.twosigma.beaker.chart.Color\ncom.twosigma.beaker.chart.GradientColor\ncom.twosigma.beaker.chart.legend.*\ncom.twosigma.beaker.chart.Filter\ncom.twosigma.beaker.chart.xychart.*\ncom.twosigma.beaker.chart.xychart.plotitem.*\ncom.twosigma.beaker.chart.categoryplot.*\ncom.twosigma.beaker.chart.categoryplot.plotitem.*\ncom.twosigma.beaker.chart.histogram.*\ncom.twosigma.beaker.chart.treemap.*\ncom.twosigma.beaker.chart.treemap.util.*\nnet.sf.jtreemap.swing.*\ncom.twosigma.beaker.chart.heatmap.HeatMap\ncom.twosigma.beaker.chart.KeyboardCodes\ncom.twosigma.beaker.jvm.object.*\ncom.twosigma.beaker.easyform.*\ncom.twosigma.beaker.easyform.formitem.*",
            "view": {
                "cm": {
                    "mode": "groovy"
                }
            }
        }
    ],
    "cells": [
        {
            "id": "sectionZpT0GU",
            "type": "section",
            "title": "What makes up the SciJava plugin framework?",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "code6n2Saq",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "// Bootstrap ImageJ. This may take some minutes the first time,",
                    "// but will be fast on subsequent runs on the same computer.",
                    "@GrabResolver(name='imagej', root='http://maven.imagej.net/content/groups/public/')",
                    "@Grab('net.imagej:imagej:2.0.0-rc-50')",
                    "import net.imagej.ImageJ"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Hidden",
                "pluginName": "Groovy",
                "shellId": "24d3ab3d-0eb0-4605-8ddb-a082bf91353b",
                "elapsedTime": 3387
            },
            "evaluatorReader": true,
            "lineCount": 5
        },
        {
            "id": "sectionE4yLib",
            "type": "section",
            "title": "The Context",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownYVcrrX",
            "type": "markdown",
            "body": [
                "References to all the <code>@Plugin</code>-annotated classes that are discovered are contained in a single, master [Context](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/Context.java). Each application is responsible for creating its own <code>Context</code> to manage plugins and contextual state.",
                "",
                "In ImageJ, a <code>Context</code> is automatically created when the [application starts up](https://github.com/imagej/imagej/blob/imagej-2.0.0-rc-39/src/main/java/net/imagej/ImageJ.java), so plugin developers do not need to create their own. In fact, creating your own <code>Context</code> typically causes problems, as it will be a different container than ImageJ is using. Instead, plugin instances within a common <code>Context</code> are provided automatically by the framework—you just have to ask for it.",
                "",
                "Typically, ImageJ plugin developers will be writing [Service](http://imagej.net/Writing_plugins#Services) and/or [Command](http://imagej.net/Writing_plugins#Commands) plugins. If you need to use another plugin - for example the [LogService](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/log/LogService.java) - you should not manually create it as this effectively disconnects you from your <code>Context</code>. Instead, you should ask your <code>Context</code> for an instance by adding a field of the desired type and annotating it with the [@Parameter](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/plugin/Parameter.java) annotation. For example:"
            ],
            "evaluatorReader": false
        },
        {
            "id": "code6Kf2Op",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "@Plugin",
                    "public class MyPlugin {",
                    " ",
                    "  // This @Parameter notation is 'asking' the Context",
                    "  // for an instance of LogService.",
                    "  @Parameter",
                    "  private LogService logService;",
                    " ",
                    "  public void log(String message) {",
                    "    // Just use the LogService!",
                    "    // There is no need to construct it, since the Context",
                    "    // has already provided an appropriate instance.",
                    "    logService.info(message);",
                    "  }",
                    "}",
                    ""
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Error",
                    "object": [
                        "org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:<br/>script14708421576421034382627.groovy: 1: unable to resolve class Plugin ,  unable to find class for annotation<br/> @ line 1, column 1.<br/>   @Plugin<br/>   ^<br/><br/>script14708421576421034382627.groovy: 6: unable to resolve class LogService <br/> @ line 6, column 3.<br/>     @Parameter<br/>     ^<br/><br/>script14708421576421034382627.groovy: 6: unable to resolve class Parameter ,  unable to find class for annotation<br/> @ line 6, column 3.<br/>     @Parameter<br/>     ^<br/><br/>3 errors<br/><br/>",
                        "\tat com.twosigma.beaker.groovy.utils.GroovyEvaluator$workerThread$MyRunnable.run(GroovyEvaluator.java:366)",
                        ""
                    ]
                },
                "selectedType": "BeakerDisplay",
                "pluginName": "Groovy",
                "shellId": "24d3ab3d-0eb0-4605-8ddb-a082bf91353b",
                "elapsedTime": 550,
                "height": 353
            },
            "evaluatorReader": true,
            "lineCount": 16
        },
        {
            "id": "markdownezExAD",
            "type": "markdown",
            "body": [
                "This will allow the <code>Context</code> to provide you with the appropriate instance of your requested service.",
                "",
                "In some cases, manual plugin construction is unavoidable. Understand that if the <code>MyPlugin</code> class above is manually constructed—i.e. via <code>new MyPlugin()</code>—the <code>LogService</code> parameter will be <code>null</code>. Automatic population only occurs if the plugin instance itself is retrieved via the framework. When you must manually construct a plugin instance, you can still re-connect it to an existing <code>Context</code> via its injection mechanism:"
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeFGpS88",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "public class MyService {",
                    " ",
                    "  // This service will manually create plugin instances.",
                    "  // So, we need a reference to our containing Context,",
                    "  // then we can use it to inject our plugins.",
                    "  @Parameter",
                    "  private Context context;",
                    " ",
                    "  public void doStuff() {",
                    "    // Manually create a plugin instance.",
                    "    // It is not connected to a Context yet",
                    "    MyPlugin plugin = new MyPlugin();",
                    " ",
                    "    // Inject the plugin instance with our Context.",
                    "    context.inject(plugin);",
                    " ",
                    "    // Now that our plugin is injected, we can use",
                    "    // it with the knowledge that its parameters",
                    "    // have been populated.",
                    "    plugin.log(\"Success!\");",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Error",
                    "object": [
                        "org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:<br/>script14708421466801880568951.groovy: 6: unable to resolve class Context <br/> @ line 6, column 3.<br/>     @Parameter<br/>     ^<br/><br/>script14708421466801880568951.groovy: 6: unable to resolve class Parameter ,  unable to find class for annotation<br/> @ line 6, column 3.<br/>     @Parameter<br/>     ^<br/><br/>script14708421466801880568951.groovy: 12: unable to resolve class MyPlugin <br/> @ line 12, column 14.<br/>       MyPlugin plugin = new MyPlugin();<br/>                ^<br/><br/>script14708421466801880568951.groovy: 12: unable to resolve class MyPlugin <br/> @ line 12, column 23.<br/>       MyPlugin plugin = new MyPlugin();<br/>                         ^<br/><br/>4 errors<br/><br/>",
                        "\tat com.twosigma.beaker.groovy.utils.GroovyEvaluator$workerThread$MyRunnable.run(GroovyEvaluator.java:366)",
                        ""
                    ]
                },
                "selectedType": "BeakerDisplay",
                "pluginName": "Groovy",
                "shellId": "24d3ab3d-0eb0-4605-8ddb-a082bf91353b",
                "elapsedTime": 950,
                "height": 433
            },
            "evaluatorReader": true,
            "lineCount": 22
        },
        {
            "id": "sectionkmU6Pi",
            "type": "section",
            "title": "Services",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownWbk4hB",
            "type": "markdown",
            "body": [
                "Services provide two important functions to the SciJava framework: utility methods and persistent state. If you want to add reusable Java methods that can be used throughout the SciJava framework, then you should create a <code>Service</code> to provide this functionality. If you need to track Context-wide variables or configuration, a <code>Service</code> should be used to encapsulate that state.",
                "",
                "Conceptually, a <code>Service</code> satisfies the role of [static utility classes](https://en.wikipedia.org/wiki/Utility_class) on a per-Context basis. In this way, only one [instance](http://math.hws.edu/javanotes/c5/s1.html ) of each <code>Service</code> class can be associated with a given <code>Context</code> instance; an association that occurs automatically during <code>Context</code> creation. Furthermore, when a <code>Context</code> is asked for an implementation of a given <code>Service</code>, only the highest priority instance will be returned.",
                "",
                "Services often build on or reuse functionality defined in each other. For example, the [PluginService](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/plugin/PluginService.java) sees ubiquitous use in retrieving and working with plugin instances. For such reuse, [@Parameter annotation](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/plugin/Parameter.java) can be used to declare inter-service requirements. During <code>Context</code> startup, these relationships will be resolved automatically."
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionTK39y9",
            "type": "section",
            "title": "Commands",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownKHLLBC",
            "type": "markdown",
            "body": [
                "Whereas [Services](http://imagej.net/Writing_plugins#Services) provide internal functionality, <code>Commands</code> are plugins designed to be executed as one-offs, typically interacting with users to achieve some desired outcome. When opening the ImageJ GUI, Commands are what populate your menu structure: exposing functionality and algorithms in a way that can be consumed by non-developers.",
                "",
                "When writing <code>Commands</code> you will often declare [@Parameters](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/plugin/Parameter.java) on fields that '''can not''' be resolved automatically by the <code>Context</code>—for example, numeric values or file paths. Instead of being instantiated at <code>Context</code> startup as a <code>Service</code> would be, <code>Commands</code> are created and executed on demand.",
                "",
                "When a <code>Command</code> is executed, it goes through a series of pre-processing steps to populate its <code>@Parameters</code> using its associated [Context](http://imagej.net/Writing_plugins#The_Context). If any parameters are left unresolved and a UI is available, the framework will automatically build and display an appropriate dialog to get user input. In this way, input harvesting is decoupled from functional operation—allowing developers to focus on what's really important without repetition of code. This also means that Commands can typically run [headlessly](http://imagej.net/Headless) without any extra development effort.",
                "",
                "A common pattern in <code>Command</code> development is to wrap <code>Service</code> functionality. For example, opening an image from a path is a fundamental operation in ImageJ. To this end, developers can directly use the [DatasetIOService](https://github.com/scifio/scifio/blob/scifio-0.25.0/src/main/java/io/scif/services/DatasetIOService.java). Users then get this same functionality from the menus via the [OpenDataset command](https://github.com/imagej/imagej-plugins-commands/blob/imagej-plugins-commands-0.6.0/src/main/java/net/imagej/plugins/commands/io/OpenDataset.java) —which itself simply calls into the <code>DatasetIOService</code>.",
                ""
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionWQtr8u",
            "type": "section",
            "title": "Other plugins",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownG7cCyX",
            "type": "markdown",
            "body": [
                "Because virtually everything is a plugin in ImageJ, there are too many to explicitly enumerate, let alone cover in a tutorial. To get ideas for functionality that can be added, a good starting point is to look for services in the [javadoc](http://javadoc.imagej.net/), or the [ImageJ search portal](http://search.imagej.net/ ). Many service types have supplemental plugins for easy functional extension. In particular, the [imagej-common](https://github.com/imagej/imagej-common/) and [scijava-common](https://github.com/scijava/scijava-common/) repositories will contain plugin definitions for many essential operations.",
                "",
                "A brief list of some of the more useful plugin types to extend:",
                "",
                "* [Ops](http://imagej.net/ImageJ_Ops) provide a reusable set of image processing algorithms.",
                "* [Image formats](http://imagej.net/Adding_new_file_formats) allow new types of images to be opened in ImageJ.",
                "* [Converters](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/convert/Converter.java) allow the framework to interchange types, outside of normal Java class hierarchy restrictions.",
                "* [Input Preprocessors](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/module/process/PreprocessorPlugin.java) give you control over the population of <code>@Parameters</code>.",
                "* [Displays](https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/display/Display.java) control how UI elements are presented to users.",
                "",
                "If you know the function you want to modify but can't determine its location in the code, please [ask other developers](http://imagej.net/Help). You're part of the community now!",
                ""
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdown43YGzz",
            "type": "markdown",
            "body": [
                "For more information on this topic, check out [this page](http://imagej.net/Writing_plugins#What_makes_up_the_SciJava_plugin_framework.3F) of the [ImageJ wiki](imagej.net)."
            ],
            "evaluatorReader": false
        }
    ],
    "namespace": {}
}
