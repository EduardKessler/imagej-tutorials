{
    "beaker": "2",
    "evaluators": [
        {
            "name": "HTML",
            "plugin": "HTML",
            "view": {
                "cm": {
                    "mode": "htmlmixed"
                }
            }
        },
        {
            "name": "JavaScript",
            "plugin": "JavaScript",
            "view": {
                "cm": {
                    "mode": "javascript",
                    "background": "#FFE0F0"
                }
            },
            "languageVersion": "ES2015"
        },
        {
            "name": "Java",
            "plugin": "Java",
            "imports": "com.twosigma.beaker.chart.Color\ncom.twosigma.beaker.chart.GradientColor\ncom.twosigma.beaker.chart.legend.*\ncom.twosigma.beaker.chart.Filter\ncom.twosigma.beaker.BeakerProgressUpdate\ncom.twosigma.beaker.chart.xychart.*\ncom.twosigma.beaker.chart.xychart.plotitem.*\ncom.twosigma.beaker.chart.categoryplot.*\ncom.twosigma.beaker.chart.categoryplot.plotitem.*\ncom.twosigma.beaker.chart.histogram.*\ncom.twosigma.beaker.chart.treemap.*\ncom.twosigma.beaker.chart.treemap.util.*\nnet.sf.jtreemap.swing.*\ncom.twosigma.beaker.NamespaceClient\ncom.twosigma.beaker.chart.heatmap.HeatMap\ncom.twosigma.beaker.jvm.object.*\ncom.twosigma.beaker.easyform.*\ncom.twosigma.beaker.easyform.formitem.*",
            "view": {
                "cm": {
                    "mode": "text/x-java"
                }
            }
        },
        {
            "name": "Groovy",
            "plugin": "Groovy",
            "imports": "graxxia.*\ncom.twosigma.beaker.NamespaceClient\ncom.twosigma.beaker.BeakerProgressUpdate\ncom.twosigma.beaker.chart.Color\ncom.twosigma.beaker.chart.GradientColor\ncom.twosigma.beaker.chart.legend.*\ncom.twosigma.beaker.chart.Filter\ncom.twosigma.beaker.chart.xychart.*\ncom.twosigma.beaker.chart.xychart.plotitem.*\ncom.twosigma.beaker.chart.categoryplot.*\ncom.twosigma.beaker.chart.categoryplot.plotitem.*\ncom.twosigma.beaker.chart.histogram.*\ncom.twosigma.beaker.chart.treemap.*\ncom.twosigma.beaker.chart.treemap.util.*\nnet.sf.jtreemap.swing.*\ncom.twosigma.beaker.chart.heatmap.HeatMap\ncom.twosigma.beaker.chart.KeyboardCodes\ncom.twosigma.beaker.jvm.object.*\ncom.twosigma.beaker.easyform.*\ncom.twosigma.beaker.easyform.formitem.*",
            "view": {
                "cm": {
                    "mode": "groovy"
                }
            }
        }
    ],
    "cells": [
        {
            "id": "sectionFLdwbe",
            "type": "section",
            "title": "ImgLib2: Introduction",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdowneXFCFn",
            "type": "markdown",
            "body": [
                "[ImgLib2](http://imagej.net/ImgLib2) is a general-purpose, multidimensional image processing library.  Writing code using ImgLib2 is independent of image dimensionality, data type, and data storage strategy.  It's designed to be reusable, to decouple algorithm development and data management, and to be extensible and adaptable through the addition of new algorithms, pixel types, and storage strategies.",
                "",
                "Find javadocs for Imglib2 [here](http://javadoc.imagej.net/ImgLib2/)."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeqcbnVd",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "/////////////////////////////////////////////////////////////////",
                    "// Bootstrap ImageJ. This may take some minutes the first time,",
                    "// but will be fast on subsequent runs on the same computer.",
                    "@GrabResolver(name='imagej', root='http://maven.imagej.net/content/groups/public/')",
                    "@Grab(group='net.imagej', module='imagej', version='2.0.0-rc-50')",
                    "import net.imagej.ImageJ",
                    "/////////////////////////////////////////////////////////////////",
                    "",
                    "///////////////////////////////////////////////////////////////////////////////",
                    "// Define an object which houses some handy notebook functions. In particular,",
                    "// we include a way to display ImgLib images (i.e., RandomAccessibleInterval",
                    "// objects) directly inside the notebook here.",
                    "",
                    "import java.awt.image.BufferedImage",
                    "import net.imagej.display.ColorTables",
                    "import net.imglib2.RandomAccessibleInterval",
                    "import net.imglib2.converter.RealLUTConverter",
                    "import net.imglib2.display.projector.composite.CompositeXYProjector",
                    "import net.imglib2.display.screenimage.awt.ARGBScreenImage",
                    "",
                    "notebook = new Object() {",
                    "  BufferedImage display(RandomAccessibleInterval source) {",
                    "    return display(source, 0, 1, -1)",
                    "  }",
                    "  BufferedImage display(RandomAccessibleInterval source, int xAxis, int yAxis, int cAxis) {",
                    "    w = (int) source.dimension(xAxis)",
                    "    h = (int) source.dimension(yAxis)",
                    "    c = 1",
                    "    target = new ARGBScreenImage(w, h)",
                    "    converters = new ArrayList<RealLUTConverter>(c);",
                    "    for (int i=0; i<c; i++) {",
                    "      converters.add(new RealLUTConverter(0, 255, ColorTables.GRAYS))",
                    "    }",
                    "    proj = new CompositeXYProjector(source, target, converters, cAxis)",
                    "    proj.map()",
                    "    return target.image()",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Text",
                "pluginName": "Groovy",
                "shellId": "015bbd92-13a8-43ce-bd4c-a833b0d43f59",
                "elapsedTime": 4600,
                "result": "script14713788943541453574080$1@4e3cffdc",
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 38
        },
        {
            "id": "sectionlAC22Y",
            "type": "section",
            "title": "Accessibles",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownTa7Tew",
            "type": "markdown",
            "body": [
                "In ImgLib2, images are represented by [_Accessibles_](http://imagej.net/ImgLib2_-_Accessibles). Image here refers to any (partial) function from coordinates to values.",
                "",
                "In the following sections we will see how pixel values can be manipulated using [_Accessors_](http://imagej.net/ImgLib2_-_Accessors). _Accessors_ are obtained from _Accessibles_. ",
                "",
                "_Accessibles_ represent the data itself. Pixel images, procedurally generated images, views into images (for instance sub-images), interpolated images, sparse collections of samples, the list of local intensity maxima of an image, list of nearest neighbors, etc., are all examples of _Accessibles_."
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionV10NVP",
            "type": "section",
            "title": "Accessors",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownzA1iqb",
            "type": "markdown",
            "body": [
                "In ImgLib2, images are manipulated using [_Accessors_](http://imagej.net/ImgLib2_-_Accessors).  For pixel images, you can think of an accessor as a movable reference to a pixel.  It can be moved around the image, even to a pixel at specific coordinates.  It can be de-referenced to get the pixel value, and it can retrieve the current position.  The accessors provided by ImgLib2 typically implement [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) of  [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html).",
                "",
                "",
                ">_NOTE:_    ",
                ">Both, [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) and [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) implement the [Sampler](http://javadoc.imagej.net/ImgLib2/net/imglib2/Sampler.html) interface which allows to access pixel values. Both implement the [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html) interface which allows to retrieve the accessors current >pixel coordinates. Both inherit (through Localizable) the [EuclideanSpace](http://javadoc.imagej.net/ImgLib2/net/imglib2/EuclideanSpace.html) interval which allows to get the number of dimensions of the image.",
                "",
                ">Note, that [Sampler](http://javadoc.imagej.net/ImgLib2/net/imglib2/Sampler.html), [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html), and [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) have a type paramer **< T >** that refers to the value type of the underlying image."
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionUdF2Lv",
            "type": "section",
            "title": "RandomAccess",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdowny0NufM",
            "type": "markdown",
            "body": [
                "[RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) provides n-dimensional random access through the [Positionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Positionable.html) interface. It can be used to access pixels at arbitrary integer coordinates. ",
                "",
                "The following code uses a RandomAccess to draw some white pixels into an image.",
                "",
                ">_NOTE:_",
                "> * **get()** is defined in the [Sampler](http://javadoc.imagej.net/ImgLib2/net/imglib2/Sampler.html) interface, so you can obtain pixel references from a Cursor in exactly the same way.",
                "> * Often, the **T** obtained from **Sampler < T >.get()** is a proxy object that is re-used internally. You should assume that moving the accessor invalidates the proxy. If you want to keep a permanent reference to a pixel, use the **Sampler < T >.copy()** method. In the above example, this would return a copy of the RandomAccess refering to the same pixel.",
                "> * The [Positionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Positionable.html), [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html), … interfaces are not restricted to accessors. In fact, many ImgLib2 entities are [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html). For instance, the [Point](http://javadoc.imagej.net/ImgLib2/net/imglib2/Point.html) class implements [Positionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Positionable.html) and [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html), and simply represents a n-dimensional coordinate. In your own code, whenever you have something that can provide coordinates, you should consider implementing [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html)."
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdownE8ltyF",
            "type": "markdown",
            "body": [
                "First, we will creat a 400x320 8-bit gray-level image."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeLsYhPl",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "import net.imglib2.img.array.ArrayImgs",
                    "",
                    "long[] dimensions = [400, 320]",
                    "img = ArrayImgs.unsignedBytes(dimensions)",
                    ""
                ]
            },
            "output": {
                "state": {},
                "result": "ArrayImg [400x320]",
                "selectedType": "Text",
                "pluginName": "Groovy",
                "shellId": "015bbd92-13a8-43ce-bd4c-a833b0d43f59",
                "elapsedTime": 597,
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 5
        },
        {
            "id": "markdownAcDxee",
            "type": "markdown",
            "body": [
                "Next, we will create a [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) to the image. Img implements the [RandomAccessible](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccessible.html) interface, thus we can use randomAccess() to obtain one. The [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) has the same generic type, [UnsignedByteType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/integer/UnsignedByteType.html), as the image."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codel9df3A",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "",
                    "r = img.randomAccess()",
                    "random = new Random()   "
                ]
            },
            "output": {
                "state": {},
                "result": "java.util.Random@7b74c572",
                "selectedType": "Text",
                "pluginName": "Groovy",
                "shellId": "015bbd92-13a8-43ce-bd4c-a833b0d43f59",
                "elapsedTime": 572,
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 3
        },
        {
            "id": "markdowndU9enK",
            "type": "markdown",
            "body": [
                "Using a **for** loop, we will set 1000 random pixels to the value of 255 (ie. _white_).  ",
                "",
                "First, we obtain the _x_, _y_ coordiantes of a random pixel within the image boundaries (_lines 2-3_). ",
                "",
                "Then we position the [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) at those coordinates using **setPosition()** from the [Positionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Positionable.html) interface, which takes two parameters, the coordinate and the dimension (_lines 4-5_), so we set the coordinate in dimension 0 to the value _x_, and we set the coordinate in dimension 1 to the value _y_.  ",
                "",
                "In _line 6_, using **get()**, we retrieve the pixel value at that coordinate; this method retunrs an instance of the pixel value type [UnsignedByteType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/integer/UnsignedByteType.html) that acts as a reference to the pixel.  ",
                "",
                "Finally, we set the pixel value to 255 (ie. _white_) via this reference (_line 7_)."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeEz83wt",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "1000.times {",
                    "  x = ( int ) ( random.nextFloat() * img.max( 0 ) )",
                    "  y = ( int ) ( random.nextFloat() * img.max( 1 ) )",
                    "  r.setPosition( x, 0 )",
                    "  r.setPosition( y, 1 )",
                    "  t = r.get()",
                    "  t.set( 255 )",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "selectedType": "BeakerDisplay",
                "pluginName": "Groovy",
                "shellId": "015bbd92-13a8-43ce-bd4c-a833b0d43f59",
                "elapsedTime": 453,
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 8
        },
        {
            "id": "markdowncFLij3",
            "type": "markdown",
            "body": [
                "Now, the image can be displayed."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeJORUUV",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "notebook.display( img )"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "ImageIcon",
                    "imageData": "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",
                    "width": 400,
                    "height": 320
                },
                "selectedType": "Image",
                "pluginName": "Groovy",
                "shellId": "015bbd92-13a8-43ce-bd4c-a833b0d43f59",
                "elapsedTime": 350,
                "height": 357
            },
            "evaluatorReader": true,
            "lineCount": 1
        },
        {
            "id": "markdownJC1lzG",
            "type": "markdown",
            "body": [
                "Before we move on to the \"other\" accessor, [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html), let's consider a generalization of the previous example. Let's say we like setting random pixels, and because we plan to do this a lot in the future, we extract this functionality into a method.",
                "",
                "Easy enough. But what if we want to apply the method to images of another value type, e.g. **DoubleType** or **ARGBType**? What if we want to apply it to a 3D image? ImgLib2 allows you to write code that handles of this transparently. ",
                "",
                "In the following example, we write a function that sets 1000 random pixels to \"white\" no matter what."
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdownqgeLHy",
            "type": "markdown",
            "body": [
                ""
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeEmBSUF",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "import java.util.Random;",
                    " ",
                    "import net.imglib2.RandomAccess;",
                    "import net.imglib2.img.Img;",
                    "import net.imglib2.img.array.ArrayImgFactory;",
                    "import net.imglib2.img.display.imagej.ImageJFunctions;",
                    "import net.imglib2.type.numeric.integer.UnsignedByteType;",
                    " ",
                    "  // There is no need to restrict ourselves to Img. ",
                    "  // We need be able to get a RandomAccess, so we need RandomAccessible<T>, ",
                    "  // and to get the number of dimensions and the extent in every dimension, ",
                    "  // so we need Interval and therefore use: RandomAccessibleInterval<T>",
                    " draw( final RandomAccessibleInterval< T > img, final T white ) {",
                    "        // get the number of dimensions",
                    "        final int n = img.numDimensions();",
                    "        // Taking a general Interval means that we no longer can assume ",
                    "        // that the interval starts at coordinates (0,0,…,0). Thus we need ",
                    "        // to make a final modification to correctly draw between min and max of the interval.",
                    "        final long[] min = new long[ n ];",
                    "        img.min( min );",
                    "        final long[] scale = new long[ n ];",
                    "        for ( int d = 0; d < n; ++d ) {",
                    "            scale[ d ] = img.max( d ) - min[ d ];",
                    "        }",
                    "        final long[] pos = new long[ n ];",
                    " ",
                    "        // create a RandomAccess to the image (now the generic type, T)",
                    "        // Img implements the RandomAccessible interface, ",
                    "        // thus we can use randomAccess() to obtain one",
                    "        final RandomAccess< T > r = img.randomAccess();",
                    "        final Random random = new Random();",
                    "        for ( int i = 0; i < 1000; ++i ) {",
                    "            // loop over all dimensions when setting the position of the RandomAccess",
                    "            for ( int d = 0; d < n; ++d ) {",
                    "                pos[ d ] = min[ d ] + ( long ) ( random.nextFloat() * scale[ d ] );",
                    "            }",
                    "            // set the position",
                    "            r.setPosition( pos );",
                    "          ",
                    "            // get() the pixel at that coordinate and ",
                    "            // set the pixel value via this reference",
                    "            r.get().set( white );",
                    "        }",
                    "    }",
                    " ",
                    "   "
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Error",
                    "object": [
                        "org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:<br/>script1471378900803133685487.groovy: 6: unable to resolve class net.imglib2.img.display.imagej.ImageJFunctions<br/> @ line 6, column 1.<br/>   import net.imglib2.img.display.imagej.ImageJFunctions;<br/>   ^<br/><br/>script1471378900803133685487.groovy: 13: unable to resolve class T <br/> @ line 13, column 40.<br/>    draw( final RandomAccessibleInterval&lt; T &gt; img, final T white ) {<br/>                                          ^<br/><br/>script1471378900803133685487.groovy: 13: unable to resolve class RandomAccessibleInterval <br/> @ line 13, column 44.<br/>   RandomAccessibleInterval&lt; T &gt; img, final<br/>                                 ^<br/><br/>script1471378900803133685487.groovy: 13: unable to resolve class T <br/> @ line 13, column 57.<br/>   bleInterval&lt; T &gt; img, final T white ) {<br/>                                 ^<br/><br/>script1471378900803133685487.groovy: 30: unable to resolve class T <br/> @ line 30, column 29.<br/>           final RandomAccess&lt; T &gt; r = img.randomAccess();<br/>                               ^<br/><br/>5 errors<br/><br/>",
                        "\tat com.twosigma.beaker.groovy.utils.GroovyEvaluator$workerThread$MyRunnable.run(GroovyEvaluator.java:366)",
                        ""
                    ]
                },
                "selectedType": "BeakerDisplay",
                "height": 513,
                "pluginName": "Groovy",
                "shellId": "015bbd92-13a8-43ce-bd4c-a833b0d43f59",
                "elapsedTime": 535
            },
            "evaluatorReader": true,
            "lineCount": 46
        },
        {
            "id": "codebmbgMK",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    " public static void main( final String[] args ) {",
                    "        // in this example, we use a 3D ARGBType image ",
                    "        // (which means a color image with red/green/blue/alpha values)",
                    "        final Img< ARGBType > img = new ArrayImgFactory< ARGBType >()",
                    "            .create( new int[] {400, 320, 100}, new ARGBType() );",
                    "        draw( img, new ARGBType( 0xffffffff ) );",
                    "        notebook.display( img )",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Error",
                    "object": "Evaluation cancelled due to a failure of an earlier cell evaluation"
                },
                "selectedType": "BeakerDisplay",
                "height": 77
            },
            "evaluatorReader": true,
            "lineCount": 9
        },
        {
            "id": "markdownlIXzRt",
            "type": "markdown",
            "body": [
                "Now we are able to apply **draw()** to many ImgLib2 constructs that are not pixel Imgs. For instance there are Views that employ on-the-fly coordinate transforms, sampled and interpolated data, etc.",
                "",
                ">_NOTE:_",
                "> * Besides **setPosition()** in a single or all dimensions, you can also relatively move a [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) in one or all dimensions, or move the [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) pixel-wise in one dimension (Have a look at the [Positionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Positionable.html) API doc!) Which of those is most efficient depends on the situation.",
                "> T* here is a **setPosition()** version which takes a [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html). Often a situation occurs where you want to position accessor _a_ to the same location as accessor _b._ In this situation you can avoid localizing _b_ into an array and using that array to set the position of _a._ You can simply **a.setPosition( b )** because _b_ is [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html).",
                "> * By _image_, we do not necessarily mean _pixel image._",
                "> * We use the generic parameter **< T extends Type< T > >** instead of **< Type >** throughout ImgLib2 since that allows us to be more type-safe. Imagine implementing an **add(a, b)** method for a certain type: using the simpler generic parameter would not allow us to enforce both parameters to have the same subclass of **Type**!",
                "> * We create as many variables as possible outside of the loop (in particular, objects) since creating objects costs a bit of execution time and can easily dominate the performance of the algorithm if one is not careful about it."
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionYwzbUJ",
            "type": "section",
            "title": "Cursor",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownNWf2i1",
            "type": "markdown",
            "body": [
                "[Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) provides iteration through the [Iterator](http://javadoc.imagej.net/ImgLib2/net/imglib2/Iterator.html) interface. It can be moved forward to visit all pixels of the image once.  The [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) concept is not limited to pixel images. A [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) can be used to iterate every collection of [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html) samples.",
                "",
                "[Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) provides iteration through the [net.imglib2.Iterator](http://javadoc.imagej.net/ImgLib2/net/imglib2/Iterator.html) interface. **Iterator.fwd()** advances the cursor. **Iterator.hasNext()** returns true if the cursor can be advanced further. Initially, a [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) points before the first element. You have to call **fwd()** once to move to the first element.",
                "",
                "Note, that the ImgLib2 [net.imglib2.Iterator](http://javadoc.imagej.net/ImgLib2/net/imglib2/Iterator.html) interface is different from Java's [java.util.Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html). However, for convenience, [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) implements [java.util.Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html) as well.",
                "",
                "Just like [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html), [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) extends [Sampler](http://javadoc.imagej.net/ImgLib2/net/imglib2/Sampler.html), so you can **get()** the value of the current pixel (respectively sample). It also implements [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html), so you can query the coordinates of the current sample.",
                "",
                "Let's look at an example: We load an image and find the maximum value (the intensity of the brightest pixel)."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codePsZDrU",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import net.imglib2.Cursor;",
                    "import net.imglib2.img.Img;",
                    "import net.imglib2.img.array.ArrayImgFactory;",
                    "import net.imglib2.io.ImgIOException;",
                    "import net.imglib2.io.ImgOpener;",
                    "import net.imglib2.type.numeric.integer.UnsignedByteType;",
                    " ",
                    "public class FindMaximumValue {",
                    "    public static void main( final String[] args ) throws ImgIOException {",
                    "        final Img< UnsignedByteType > img = new ImgOpener().openImg( \"graffiti.tif\",",
                    "            new ArrayImgFactory< UnsignedByteType >(), new UnsignedByteType() );",
                    "      ",
                    "        // we get a Cursor from the image",
                    "        final Cursor< UnsignedByteType > cursor = img.cursor();",
                    "        int max = 0;",
                    "      ",
                    "        // we iterate over the image ",
                    "        while ( cursor.hasNext() ) {",
                    "            // get the value at the current position",
                    "            // (again,this is an instance of the pixel ",
                    "            // value type UnsignedByteType that ",
                    "            // acts as a reference to the pixel)",
                    "            final UnsignedByteType t = cursor.next();",
                    "            max = Math.max( t.get(), max );",
                    "        }",
                    "        System.out.println( \"max = \" + max );",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Error",
                    "object": "Evaluation cancelled due to a failure of an earlier cell evaluation"
                },
                "selectedType": "BeakerDisplay",
                "height": 77
            },
            "evaluatorReader": true,
            "lineCount": 28
        },
        {
            "id": "markdownaRyqSH",
            "type": "markdown",
            "body": [
                "Let's extend the previous example. Now we are also interested in the coordinates of the maximum. [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) extends the [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html) interface which provides methods to get the current location either dimension-by-dimension or all at once.  And let's do this via a generic version; for example, we will not take an **Img< T >** as the parameter, because that would be too restrictive."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeURnKML",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import net.imglib2.Cursor;",
                    "import net.imglib2.IterableInterval;",
                    "import net.imglib2.img.Img;",
                    "import net.imglib2.img.array.ArrayImgFactory;",
                    "import net.imglib2.io.ImgIOException;",
                    "import net.imglib2.io.ImgOpener;",
                    "import net.imglib2.type.Type;",
                    "import net.imglib2.type.numeric.integer.UnsignedByteType;",
                    " ",
                    "public class FindMaximumValueAndLocationGeneric {",
                    "    // IterableInterval<T> is the most general type to use, but must be Comparable",
                    "    // the return value of findmax is a Cursor<T>, holds value and coordinates",
                    "    public static < T extends Comparable< T > >",
                    "            Cursor< T > findmax( final IterableInterval< T > iterable ) {",
                    "        final Cursor< T > cursor = iterable.cursor();",
                    "        cursor.fwd();",
                    "        Cursor< T > max = cursor.copyCursor();",
                    "      while ( cursor.hasNext() ) {",
                    "        // to remember the maximum, we simply take a new copy ",
                    "        // of the iterating cursor whenever a better max value is found",
                    "        if ( cursor.next().compareTo( max.get() ) > 0 ) {",
                    "                max = cursor.copyCursor();",
                    "        }",
                    "      }",
                    "        return max;",
                    "    }",
                    " ",
                    "    public static void main( final String[] args ) throws ImgIOException {",
                    "        final Img< UnsignedByteType > img = new ImgOpener().openImg( \"graffiti.tif\",",
                    "            new ArrayImgFactory< UnsignedByteType >(), new UnsignedByteType() );",
                    "        // use findmax and get the maximum value and coordinates from the resulting Cursor,",
                    "        // using the dimension-by-dimension getLongPosition() of the Localizable interface",
                    "        final Cursor< UnsignedByteType > max = findmax( img );",
                    "        System.out.println( \"max = \" + max.get().get() );",
                    "        System.out.println( \"found at ( \" + max.getLongPosition( 0 ) + \", \" +",
                    "                                            max.getLongPosition( 1 ) + \")\" );",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Error",
                    "object": "Evaluation cancelled due to a failure of an earlier cell evaluation"
                },
                "selectedType": "BeakerDisplay",
                "height": 151
            },
            "evaluatorReader": true,
            "lineCount": 38
        },
        {
            "id": "markdown0WQBpZ",
            "type": "markdown",
            "body": [
                "> _NOTE:_",
                "> * The iteration order is subject to implementation, specialized for each memory layout to minimize access time. For example, an [ArrayImg](http://javadoc.imagej.net/ImgLib2/net/imglib2/img/array/ArrayImg.html) has a different iteration order from a [CellImg](http://javadoc.imagej.net/ImgLib2/net/imglib2/cell/CellImg.html). This is nicely illustrated in [ImgLib2 Example 2b - Duplicating an Img using a different ImgFactory](http://imagej.net/ImgLib2_Examples#Example_2b_-_Duplicating_an_Img_using_a_different_ImgFactory).",
                "> * Typically, there are two variants of [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) available. One that calculates its location per each iteration and one that calculates it only per localization request. The former is more efficient when localization occurs frequently, the latter otherwise. In the maximum-finding example, we use the latter because localization is only required once after the maximum has been found. The former one could be obtained using **localizingCursor()** instead of **cursor()** (see [IterableInterval](http://javadoc.imagej.net/ImgLib2/net/imglib2/IterableInterval.html) API doc)",
                "> * **copyCursor()** is a work-around to circumvent a javac bug with covariant return type overriding. In the future (with JDK7) every [Sampler](http://javadoc.imagej.net/ImgLib2/net/imglib2/Sampler.html) can be copied using **copy()** instead of having specialised **copyCursor()**, **copyRandomAccess()**, … methods."
            ],
            "evaluatorReader": false
        },
        {
            "id": "markdownyrt159",
            "type": "markdown",
            "body": [
                "ImgLib2 is not restricted to rasterized images and integer coordinates It also supports continuous images and real-valued coordinates. Examples where this is appropriate are",
                "",
                "* an interpolated image, where an interpolated value can be obtained at any real coordinate. Note that this is a bounded, but continuous image. Thus it is not iterable.",
                "* a procedurally generated image, where a value can be computed at any real coordinate (continuous, unbounded, non-iterable).",
                "* collections of samples taken at arbitrary real coordinates (discrete, bounded, iterable).",
                "",
                "Real equivalents of the [Positionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Positionable.html) and [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html) interfaces have been added by which real-valued coordinates can be accessed, [RealPositionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealPositionable.html) and [RealLocalizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealLocalizable.html), respectively.   [RealPositionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealPositionable.html) extends [Positionable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Positionable.html), because whenever something can be positioned at arbitrary real coordinates, of course it can be positioned to integer coordinates as well.  [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html) extends [RealLocalizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealLocalizable.html), as something that is able to provide its integer coordinates is always able to provide them as real coordinates too.",
                "",
                "Both, [RealRandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealRandomAccess.html) and [RealCursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealCursor.html) are [RealLocalizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealLocalizable.html). Note that the inheritance relationship of [Localizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/Localizable.html) and [RealLocalizable](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealLocalizable.html) propagates to the cursors. Every [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) is also a [RealCursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealCursor.html) (because it can provide its current integer coordinates as real coordinates as well). There is no such relationship between [RandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccess.html) and [RealRandomAccess](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealRandomAccess.html).",
                "",
                "You can read more about this final topic and see example code [here](http://imagej.net/ImgLib2_-_Accessors#Accessors_for_Continuous_Coordinates)."
            ],
            "evaluatorReader": false
        }
    ],
    "namespace": {}
}
