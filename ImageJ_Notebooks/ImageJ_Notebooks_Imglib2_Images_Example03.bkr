{
    "beaker": "2",
    "evaluators": [
        {
            "name": "HTML",
            "plugin": "HTML",
            "view": {
                "cm": {
                    "mode": "htmlmixed"
                }
            }
        },
        {
            "name": "TeX",
            "plugin": "TeX",
            "view": {
                "cm": {
                    "mode": "stex"
                }
            }
        },
        {
            "name": "IPython",
            "plugin": "IPython",
            "imports": "",
            "supplementalClassPath": "",
            "view": {
                "cm": {
                    "mode": "python"
                }
            },
            "setup": "%matplotlib inline\nimport numpy\nimport matplotlib\nfrom matplotlib import pylab, mlab, pyplot\nnp = numpy\nplt = pyplot\nfrom IPython.display import display\nfrom IPython.core.pylabtools import figsize, getfigs\nfrom pylab import *\nfrom numpy import *\n"
        },
        {
            "name": "JavaScript",
            "plugin": "JavaScript",
            "jsSetting2": "",
            "jsSetting1": "",
            "view": {
                "cm": {
                    "mode": "javascript",
                    "background": "#FFE0F0"
                }
            },
            "languageVersion": "ES2015"
        },
        {
            "name": "R",
            "plugin": "R",
            "view": {
                "cm": {
                    "mode": "r"
                }
            }
        },
        {
            "name": "Groovy",
            "plugin": "Groovy",
            "imports": "graxxia.*\ncom.twosigma.beaker.NamespaceClient\ncom.twosigma.beaker.BeakerProgressUpdate\ncom.twosigma.beaker.chart.Color\ncom.twosigma.beaker.chart.GradientColor\ncom.twosigma.beaker.chart.legend.*\ncom.twosigma.beaker.chart.Filter\ncom.twosigma.beaker.chart.xychart.*\ncom.twosigma.beaker.chart.xychart.plotitem.*\ncom.twosigma.beaker.chart.categoryplot.*\ncom.twosigma.beaker.chart.categoryplot.plotitem.*\ncom.twosigma.beaker.chart.histogram.*\ncom.twosigma.beaker.chart.treemap.*\ncom.twosigma.beaker.chart.treemap.util.*\nnet.sf.jtreemap.swing.*\ncom.twosigma.beaker.chart.heatmap.HeatMap\ncom.twosigma.beaker.chart.KeyboardCodes\ncom.twosigma.beaker.jvm.object.*\ncom.twosigma.beaker.easyform.*\ncom.twosigma.beaker.easyform.formitem.*",
            "view": {
                "cm": {
                    "mode": "groovy"
                }
            }
        }
    ],
    "cells": [
        {
            "id": "section001",
            "type": "section",
            "level": 1,
            "title": "ImgLib2 \n\nExample 03: Writing generic algorithms",
            "collapsed": false,
            "evaluatorReader": false
        },
        {
            "id": "markdown9dHd5C",
            "type": "markdown",
            "body": [
                "**Imglib2 Examples 01 and 02** tried to introduce important tools you need in order to implement algorithms with ImgLib2. This example will show three generic implementations of algorithms computing the min/max, average, as well as the center of mass.",
                "",
                "The core idea is to implement algorithms as generic as possible in order to maximize code-*reusability.* In general, a good way to start is to think: What are the minimal requirements in order to implement algorithm X? This applies to all of the following three concepts:",
                "",
                "* **Type**: You should always use the most abstract [Type](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/Type.html) possible, i.e. the one that just offers enough operations to perform your goal. In this way, the algorithm will be able to run on [Type](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/Type.html)s you might not even have thought about when implementing it. A good example is the min&max search in example 3a. Instead of implementing it for [FloatType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/real/FloatType.html) or the more abstract [RealType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/RealType.html), we implement it for the even more abstract [Comparable](https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html) & [Type](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/Type.html).",
                "* **Image data**: Every algorithm should only demand those interfaces that it requires, not specific implementations of it like [Img](http://javadoc.imagej.net/ImgLib2/net/imglib2/img/Img.html). You might require [RandomAccessible](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccessible.html) (infinite), [RandomAccessibleInterval](http://javadoc.imagej.net/ImgLib2/net/imglib2/RandomAccessibleInterval.html) (finite), [Iterable](http://javadoc.imagej.net/Java/java/lang/Iterable.html?is-external=true) (values without location), [IterableInterval](http://javadoc.imagej.net/ImgLib2/net/imglib2/IterableInterval.html) (values and their location) or their corresponding interfaces for real-valued locations [RealRandomAccessible](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealRandomAccessible.html), [RealRandomAccessibleRealInterval](http://javadoc.imagej.net/ImgLib2/net/imglib2/RealRandomAccessibleRealInterval.html) and [IterableRealInterval](http://javadoc.imagej.net/ImgLib2/net/imglib2/IterableRealInterval.html). Note that you can concatenate them if you need more than one property.",
                "* **Dimensionality**: Usually there is no reason to restrict an algorithm to a certain dimensionality (like only for two-dimensional images), at least we could not really come up with an convincing example *If the application or plugin your are developing addresses a certain dimensionality (e.g. stitching of panorama photos) it is understandable that you do not want to implement everything n-dimensionally. But try to implement as many as possible of the smaller algorithm you are using as generic, n-dimensional methods. For example, everything that requires only to **iterate** the data is usually inherently n-dimensional.*",
                "",
                "Following those ideas, your newly implemented algorithm will be applicable to any kind of data and dimensionality it is defined for, not only a very small domain you are currently working with. Also note that quite often this actually makes the implementation simpler."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeGB53Md",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "/////////////////////////////////////////////////////////////////",
                    "// Bootstrap ImageJ. This may take some minutes the first time,",
                    "// but will be fast on subsequent runs on the same computer.",
                    "@GrabResolver(name='imagej', root='http://maven.imagej.net/content/groups/public/')",
                    "@Grab(group='net.imagej', module='imagej', version='2.0.0-rc-50')",
                    "import net.imagej.ImageJ",
                    "/////////////////////////////////////////////////////////////////",
                    "",
                    "///////////////////////////////////////////////////////////////////////////////",
                    "// Define an object which houses some handy notebook functions. In particular,",
                    "// we include a way to display ImgLib images (i.e., RandomAccessibleInterval",
                    "// objects) directly inside the notebook here.",
                    "",
                    "import java.awt.image.BufferedImage",
                    "import net.imagej.display.ColorTables",
                    "import net.imglib2.RandomAccessibleInterval",
                    "import net.imglib2.converter.RealLUTConverter",
                    "import net.imglib2.display.projector.composite.CompositeXYProjector",
                    "import net.imglib2.display.screenimage.awt.ARGBScreenImage",
                    "import net.imglib2.view.Views",
                    "",
                    "notebook = new Object() {",
                    "  BufferedImage display(RandomAccessibleInterval source) {",
                    "    return display(source, 0, 1, -1)",
                    "  }",
                    "  BufferedImage display(RandomAccessibleInterval source, int xAxis, int yAxis, int cAxis) {",
                    "    offset = new long[source.numDimensions()]",
                    "    for (int d = 0; d < offset.length; d++) {",
                    "     offset[d] = -source.min(d) ",
                    "    }",
                    "    image = Views.translate(source, offset)",
                    "    ",
                    "    w = (int) image.dimension(xAxis)",
                    "    h = (int) image.dimension(yAxis)",
                    "    c = 1",
                    "    target = new ARGBScreenImage(w, h)",
                    "    converters = new ArrayList<RealLUTConverter>(c);",
                    "    for (int i=0; i<c; i++) {",
                    "      converters.add(new RealLUTConverter(0, 255, ColorTables.GRAYS))",
                    "    }",
                    "    proj = new CompositeXYProjector(image, target, converters, cAxis)",
                    "    proj.map()",
                    "    return target.image()",
                    "  }",
                    "}"
                ]
            },
            "output": {
                "state": {}
            },
            "evaluatorReader": true,
            "lineCount": 45
        },
        {
            "id": "sectionK2rrg9",
            "type": "section",
            "title": "Min/Max search",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownZ2C71U",
            "type": "markdown",
            "body": [
                "Searching for the minimal and maximal value in a dataset is a very nice example to illustrate generic algorithms. In order to find min/max values, [Type](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/Type.html)s only need to be able to compare themselves. Therefore we do not need any numeric values, we only require them to implement the (Java) interface [Comparable](https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html). Additionally, no random access to the data is required, we simply need to iterate all pixels, also their location is irrelevant. The image data we need only needs to be [Iterable](http://javadoc.imagej.net/Java/java/lang/Iterable.html?is-external=true).",
                "",
                "Below we show **three** small variations of the min/max search. ",
                "* First, in Example 03.01, we show the implementation as described above. ",
                "* Second, in Example 03.02, we illustrate that this also works on a standard Java ArrayList. ",
                "* Third, in Example 03.03, we show how the implementation changes if we do not only want the min/max value, but also their location. This requires to use [IterableInterval](http://javadoc.imagej.net/ImgLib2/net/imglib2/IterableInterval.html) instead, as [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) can return their location."
            ],
            "evaluatorReader": false
        },
        {
            "id": "sectionHeUEkV",
            "type": "section",
            "title": "Example 03.01",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "code1dfC79",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "import io.scif.img.ImgIOException;",
                    "import io.scif.img.ImgOpener;",
                    " ",
                    "import java.util.Iterator;",
                    " ",
                    "import net.imglib2.Cursor;",
                    "import net.imglib2.RandomAccess;",
                    "import net.imglib2.img.Img;",
                    "import net.imglib2.type.NativeType;",
                    "import net.imglib2.type.Type;",
                    "import net.imglib2.type.numeric.RealType;",
                    " ",
                    "/**",
                    " * Perform a generic min & max search",
                    " *",
                    " * @author Stephan Preibisch & Stephan Saalfeld",
                    " *",
                    " */",
                    "public class Example3a1",
                    "{",
                    "    public < T extends RealType< T > & NativeType< T > > Example3a1()",
                    "        throws ImgIOException",
                    "    {",
                    "        // open with ImgOpener (he will decide which Img is best)",
                    "        Img< T > img = (Img< T >) new ImgOpener().openImg( \"DrosophilaWing.tif\" );",
                    " ",
                    "        // create two empty variables",
                    "        T min = img.firstElement().createVariable();",
                    "        T max = img.firstElement().createVariable();",
                    " ",
                    "        // compute min and max of the Image",
                    "        computeMinMax( img, min, max );",
                    " ",
                    "        System.out.println( \"minimum Value (img): \" + min );",
                    "        System.out.println( \"maximum Value (img): \" + max );",
                    "    }",
                    " ",
                    "    /**",
                    "     * Compute the min and max for any {@link Iterable}, like an {@link Img}.",
                    "     *",
                    "     * The only functionality we need for that is to iterate. Therefore we need no {@link Cursor}",
                    "     * that can localize itself, neither do we need a {@link RandomAccess}. So we simply use the",
                    "     * most simple interface in the hierarchy.",
                    "     *",
                    "     * @param input - the input that has to just be {@link Iterable}",
                    "     * @param min - the type that will have min",
                    "     * @param max - the type that will have max",
                    "     */",
                    "    public < T extends Comparable< T > & Type< T > > void computeMinMax(",
                    "        final Iterable< T > input, final T min, final T max )",
                    "    {",
                    "        // create a cursor for the image (the order does not matter)",
                    "        final Iterator< T > iterator = input.iterator();",
                    " ",
                    "        // initialize min and max with the first image value",
                    "        T type = iterator.next();",
                    " ",
                    "        min.set( type );",
                    "        max.set( type );",
                    " ",
                    "        // loop over the rest of the data and determine min and max value",
                    "        while ( iterator.hasNext() )",
                    "        {",
                    "            // we need this type more than once",
                    "            type = iterator.next();",
                    " ",
                    "            if ( type.compareTo( min ) < 0 )",
                    "                min.set( type );",
                    " ",
                    "            if ( type.compareTo( max ) > 0 )",
                    "                max.set( type );",
                    "        }",
                    "    }",
                    " ",
                    "    public static void main( String[] args ) throws ImgIOException",
                    "    {",
                    "        // run the example",
                    "        new Example3a1();",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {}
            },
            "evaluatorReader": true,
            "lineCount": 80
        },
        {
            "id": "sectionZZWifn",
            "type": "section",
            "title": "Example 03.02",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownQlYXy7",
            "type": "markdown",
            "body": [
                "Note that this example works just the same way if the input is not an [Img](http://javadoc.imagej.net/ImgLib2/net/imglib2/img/Img.html), but for example just a standard Java [ArrayList](https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html)."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codefjW8SJ",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "import java.util.ArrayList;",
                    "import java.util.Iterator;",
                    " ",
                    "import net.imglib2.Cursor;",
                    "import net.imglib2.RandomAccess;",
                    "import net.imglib2.img.Img;",
                    "import net.imglib2.type.Type;",
                    "import net.imglib2.type.numeric.real.FloatType;",
                    " ",
                    "/**",
                    " * Perform a generic min & max search",
                    " *",
                    " * @author Stephan Preibisch & Stephan Saalfeld",
                    " *",
                    " */",
                    "public class Example3a2",
                    "{",
                    "    public Example3a2()",
                    "    {",
                    "        // it will work as well on a normal ArrayList",
                    "        ArrayList< FloatType > list = new ArrayList< FloatType >();",
                    " ",
                    "        // put values 0 to 10 into the ArrayList",
                    "        for ( int i = 0; i <= 10; ++i )",
                    "            list.add( new FloatType( i ) );",
                    " ",
                    "        // create two empty variables",
                    "        FloatType min = new FloatType();",
                    "        FloatType max = new FloatType();",
                    " ",
                    "        // compute min and max of the ArrayList",
                    "        computeMinMax( list, min, max );",
                    " ",
                    "        System.out.println( \"minimum Value (arraylist): \" + min );",
                    "        System.out.println( \"maximum Value (arraylist): \" + max );",
                    "    }",
                    " ",
                    "    /**",
                    "     * Compute the min and max for any {@link Iterable}, like an {@link Img}.",
                    "     *",
                    "     * The only functionality we need for that is to iterate. Therefore we need no {@link Cursor}",
                    "     * that can localize itself, neither do we need a {@link RandomAccess}. So we simply use the",
                    "     * most simple interface in the hierarchy.",
                    "     *",
                    "     * @param input - the input that has to just be {@link Iterable}",
                    "     * @param min - the type that will have min",
                    "     * @param max - the type that will have max",
                    "     */",
                    "    public < T extends Comparable< T > & Type< T > > void computeMinMax(",
                    "        final Iterable< T > input, final T min, final T max )",
                    "    {",
                    "        // create a cursor for the image (the order does not matter)",
                    "        final Iterator< T > iterator = input.iterator();",
                    " ",
                    "        // initialize min and max with the first image value",
                    "        T type = iterator.next();",
                    " ",
                    "        min.set( type );",
                    "        max.set( type );",
                    " ",
                    "        // loop over the rest of the data and determine min and max value",
                    "        while ( iterator.hasNext() )",
                    "        {",
                    "            // we need this type more than once",
                    "            type = iterator.next();",
                    " ",
                    "            if ( type.compareTo( min ) < 0 )",
                    "                min.set( type );",
                    " ",
                    "            if ( type.compareTo( max ) > 0 )",
                    "                max.set( type );",
                    "        }",
                    "    }",
                    " ",
                    "    public static void main( String[] args )",
                    "    {",
                    "        // run the example",
                    "        new Example3a2();",
                    "    }",
                    "}",
                    ""
                ]
            },
            "output": {
                "state": {}
            },
            "evaluatorReader": true,
            "lineCount": 81
        },
        {
            "id": "sectionRRu5Oy",
            "type": "section",
            "title": "Example 03.03",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownm1zx2E",
            "type": "markdown",
            "body": [
                "If we want to compute the location of the minimal and maximal pixel value, an [Iterator](http://javadoc.imagej.net/ImgLib2/net/imglib2/Iterator.html) will not be sufficient as we need location information. Instead, the location search will demand an [IterableInterval](http://javadoc.imagej.net/ImgLib2/net/imglib2/IterableInterval.html) as input data which can create [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html)s. Apart from that, the algorithm looks quite similar. Note that we do not use a **LocalizingCursor** but only a [Cursor](http://javadoc.imagej.net/ImgLib2/net/imglib2/Cursor.html) the location happens only when a new maximal or minimal value has been found while iterating the data."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeUtGVZu",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "import io.scif.img.ImgIOException;",
                    "import io.scif.img.ImgOpener;",
                    "import net.imglib2.Cursor;",
                    "import net.imglib2.IterableInterval;",
                    "import net.imglib2.Point;",
                    "import net.imglib2.img.Img;",
                    "import net.imglib2.type.NativeType;",
                    "import net.imglib2.type.Type;",
                    "import net.imglib2.type.numeric.RealType;",
                    " ",
                    "/**",
                    " * Perform a generic min/max search.",
                    " *",
                    " * @author Stephan Preibisch & Stephan Saalfeld",
                    " *",
                    " */",
                    "public class Example3a3",
                    "{",
                    "    public < T extends RealType< T > & NativeType< T > > Example3a3()",
                    "        throws ImgIOException",
                    "    {",
                    "        // open with ImgOpener (he will decide which Img is best)",
                    "        Img< T > img = (Img< T >) new ImgOpener().openImg( \"DrosophilaWing.tif\" );",
                    " ",
                    "        // create two location objects",
                    "        Point locationMin = new Point( img.numDimensions() );",
                    "        Point locationMax = new Point( img.numDimensions() );",
                    " ",
                    "        // compute location of min and max",
                    "        computeMinMaxLocation( img, locationMin, locationMax );",
                    " ",
                    "        System.out.println( \"location of minimum Value (img): \" + locationMin );",
                    "        System.out.println( \"location of maximum Value (img): \" + locationMax );",
                    "    }",
                    " ",
                    "    /**",
                    "     * Compute the location of the minimal and maximal intensity for any IterableInterval,",
                    "     * like an {@link Img}.",
                    "     *",
                    "     * The functionality we need is to iterate and retrieve the location. Therefore we need a",
                    "     * Cursor that can localize itself.",
                    "     * Note that we do not use a LocalizingCursor as localization just happens from time to time.",
                    "     *",
                    "     * @param input - the input that has to just be {@link IterableInterval}",
                    "     * @param minLocation - the location for the minimal value",
                    "     * @param maxLocation - the location of the maximal value",
                    "     */",
                    "    public < T extends Comparable< T > & Type< T > > void computeMinMaxLocation(",
                    "        final IterableInterval< T > input, final Point minLocation, final Point maxLocation )",
                    "    {",
                    "        // create a cursor for the image (the order does not matter)",
                    "        final Cursor< T > cursor = input.cursor();",
                    " ",
                    "        // initialize min and max with the first image value",
                    "        T type = cursor.next();",
                    "        T min = type.copy();",
                    "        T max = type.copy();",
                    " ",
                    "        // loop over the rest of the data and determine min and max value",
                    "        while ( cursor.hasNext() )",
                    "        {",
                    "            // we need this type more than once",
                    "            type = cursor.next();",
                    " ",
                    "            if ( type.compareTo( min ) < 0 )",
                    "            {",
                    "                min.set( type );",
                    "                minLocation.setPosition( cursor );",
                    "            }",
                    " ",
                    "            if ( type.compareTo( max ) > 0 )",
                    "            {",
                    "                max.set( type );",
                    "                maxLocation.setPosition( cursor );",
                    "            }",
                    "        }",
                    "    }",
                    " ",
                    "    public static void main( String[] args ) throws ImgIOException",
                    "    {",
                    "        // run the example",
                    "        new Example3a3();",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {}
            },
            "evaluatorReader": true,
            "lineCount": 84
        },
        {
            "id": "section9bqVrv",
            "type": "section",
            "title": "Computing average",
            "level": 2,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownBoF4Zu",
            "type": "markdown",
            "body": [
                "In a very similar way, one can compute the average intensity for image data. Note that we restrict the [Type](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/Type.html) of data to [RealType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/RealType.html). In theory, we could use [NumericType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/NumericType.html) as it offers the possibility to add up values. However, we cannot ensure that [NumericType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/NumericType.html) provided is capable of adding up millions of pixels without overflow. And even if we would ask for a second [NumericType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/NumericType.html) that is capable of adding values up, it might still have numerical instabilities. Note that actually every Java native type has those instabilities. Therefore we use the [RealSum](http://javadoc.imagej.net/ImgLib2/net/imglib2/util/RealSum.html) class that offers correct addition of even very large amounts of pixels. As this implementation is only available for double values, we restrict the method here to [RealType](http://javadoc.imagej.net/ImgLib2/net/imglib2/type/numeric/RealType.html)."
            ],
            "evaluatorReader": false
        },
        {
            "id": "codeuKSmMY",
            "type": "code",
            "evaluator": "Groovy",
            "input": {
                "body": [
                    "import io.scif.img.ImgIOException;",
                    "import io.scif.img.ImgOpener;",
                    "import net.imglib2.img.Img;",
                    "import net.imglib2.type.NativeType;",
                    "import net.imglib2.type.numeric.RealType;",
                    "import net.imglib2.util.RealSum;",
                    " ",
                    "/**",
                    " * Perform a generic computation of average intensity",
                    " *",
                    " * @author Stephan Preibisch & Stephan Saalfeld",
                    " *",
                    " */",
                    "public class Example3b",
                    "{",
                    "    public < T extends RealType< T > & NativeType< T > > Example3b() throws",
                    "        ImgIOException",
                    "    {",
                    "        // open with ImgOpener",
                    "        final Img< T > img = (Img< T >) new ImgOpener().openImg( \"DrosophilaWing.tif\" );",
                    " ",
                    "        // compute average of the image",
                    "        final double avg = computeAverage( img );",
                    "        System.out.println( \"average Value: \" + avg );",
                    "    }",
                    " ",
                    "    /**",
                    "     * Compute the average intensity for an {@link Iterable}.",
                    "     *",
                    "     * @param input - the input data",
                    "     * @return - the average as double",
                    "     */",
                    "    public < T extends RealType< T > > double computeAverage( final Iterable< T > input )",
                    "    {",
                    "        // Count all values using the RealSum class.",
                    "        // It prevents numerical instabilities when adding up millions of pixels",
                    "        final RealSum realSum = new RealSum();",
                    "        long count = 0;",
                    " ",
                    "        for ( final T type : input )",
                    "        {",
                    "            realSum.add( type.getRealDouble() );",
                    "            ++count;",
                    "        }",
                    " ",
                    "        return realSum.getSum() / count;",
                    "    }",
                    " ",
                    "    public static void main( final String[] args ) throws ImgIOException",
                    "    {",
                    "        // run the example",
                    "        new Example3b();",
                    "    }",
                    "}"
                ]
            },
            "output": {
                "state": {}
            },
            "evaluatorReader": true,
            "lineCount": 54
        }
    ],
    "namespace": {}
}
